#!/usr/bin/env python3
import argparse
import construct
import hashlib
import json
import os
import pprint
import re
import tempfile
import shutil
import sys
from datetime import datetime
from formats.flac import FlacFile, FlacMetadataFormat
from formats.mp3 import Mp3File, Mp3MetadataFormat
from construct import *
from pathlib import Path


# Version 2 is used only for "freeze --backup" freezetags.
# All other freezetags are still created using version 1 so the bytes/IDs stay consistent.
# These can be unified in a future version if the schema is updated.
DEFAULT_VERSION = 1
VERSION = 2

freeze_modes = ['default', 'backup']
registered_filetypes = [FlacFile, Mp3File]
filetype_for_extension = {t.extension:t for t in registered_filetypes}


class Reprinter():
    def __init__(self):
        self.last_width = 0

    def print(self, text):
        text = str(text)
        print(text.ljust(self.last_width, ' '), end='\r')
        self.last_width = len(text)


def get_version():
    if args.backup:
        return VERSION
    return DEFAULT_VERSION


def parse_args():
    parent = argparse.ArgumentParser(add_help=False)
    main = argparse.ArgumentParser(parents=[parent],
        epilog='Use "freezetag [command] --help" for more information about a command.',
        description='Saves, strips, and restores file paths and music metadata.',
        formatter_class=argparse.RawTextHelpFormatter)
    sub = main.add_subparsers(metavar='command', dest='command')
    sub.required = True

    def add_subparser(command, help, description=''):
        return sub.add_parser(command, help=help, description=help + description,
                              formatter_class=argparse.RawTextHelpFormatter, parents=[parent])

    freeze = add_subparser('freeze', 'Saves paths and music metadata in directory to a freezetag file.',
        '\n\nMusic files with supported extensions (.mp3, .flac) will have their metadata'
          '\nsaved in the .ftag file. All files will have their paths saved in the .ftag'
          '\nfile. Metadata and path state can be restored using "freezetag thaw".'
        '\n\nThe freezetag file will be saved in directory. Unless --backup is used, the'
          '\nfreezetag file will be named Fa-b-c.ftag, where:'
          '\n  a is a 16-character segment that uniquely identifies the music'
          '\n  b is an 8-character segment that uniquely identifies the metadata'
          '\n  c is an 8-character segment that uniquely identifies the freezetag'
        '\n\nThe "a" and "b" segments do not change between freezes if any paths change or'
          '\nif any non-music files are modified. Additionally, the "a" segment doesn\'t'
          '\nchange if the music files are retagged.'
        '\n\nThis means if two different .ftag files have the same "a" segment, they'
          '\nrepresent the same set of raw music. If they have both the same "a" and "b"'
          '\nsegments, they represent the same set of raw music AND their metadata.'
    )

    thaw = add_subparser('thaw', 'Restores paths and music metdata in directory from a freezetag file.')
    shave = add_subparser('shave', 'Strips metadata from all music files in directory.',
            '\n\nOnly music files with supported extensions (.mp3, .flac) will be modified,'
              '\nand only supported metadata (Vorbis comments, ID3) will be stripped.')
    show = add_subparser('show', 'Displays the contents of a freezetag file.')

    for parser in [freeze, thaw, shave]:
        parser.add_argument('directory', nargs='?', default=Path.cwd(),
            help='Directory to process (default: current directory).')

    show.add_argument('directory', nargs='?', metavar='path', default=Path.cwd(),
        help='Directory containing .ftag file, or .ftag file itself\n'
             '(default: current directory)')
    show.add_argument('--json', action='store_true', help='Prints JSON output.')

    thaw.add_argument('--ftag', metavar='file', help='Freezetag file to use. Uses the .ftag in directory by default.')
    thaw.add_argument('--to', metavar='directory',
        help='Directory to which thawed state will be restored. By default,'
        '\nthe state will be restored in-place to directory, replacing'
        '\nexisting tags and paths.')

    freeze.add_argument('--backup', action='store_true',
        help='Freeze in incremental backup mode.'
        '\n\nThis mode is optimized for repeated incremental backups of the'
          '\nsame directory.'
        '\n\nIn backup mode, the freezetag file will be saved as'
          '\nFyyyy-MM-dd_hh-mm-ss.ftag. File sizes and last modified times'
          '\nwill be written to the freezetag file. On subsequent incremental'
          '\nbackups, the last created freezetag in this directory will be'
          '\nread. Any files whose names haven\'t changed will not have their'
          '\nhashes recalculated, making the freeze operation significantly'
          '\nfaster.')

    return main.parse_args()


FrozenFormatV1 = Struct(
    'mode' / Computed(0),
    'music_checksum' / Bytes(8),
    'metadata_checksum' / Bytes(4),
    'root' / CString('utf8'),
    'files' / Compressed(PrefixedArray(Int16ub, Struct(
        'path' / CString('utf8'),
        'format' / Int8ub,
        'checksum' / Bytes(20),
        'metadata' / Switch(this.format, {
            1: FlacFile.metadata_format,
            2: Mp3File.metadata_format,
        }),
    )), 'lzma'),
)

FrozenFormatV2 = Struct(
    'mode' / Int8ub,
    'music_checksum' / Bytes(8),
    'metadata_checksum' / Bytes(4),
    'root' / CString('utf8'),
    'files' / Compressed(PrefixedArray(Int16ub, Struct(
        'path' / CString('utf8'),
        'format' / Int8ub,
        'checksum' / Bytes(20),
        'stat' / If(this._._.mode == 1, Struct(
            'mtime' / Double,
            'size' / Long,
        )),
        'metadata' / Switch(this.format, {
            1: FlacFile.metadata_format,
            2: Mp3File.metadata_format,
        }),
    )), 'lzma'),
)

FreezeFormat = Struct(
    'signature' / Const(b'freezetag'),
    'version'/ Int8ub,
    'frozen' / Switch(this.version, {
        1: FrozenFormatV1,
        2: FrozenFormatV2,
    }, GreedyBytes),
    Terminated,
)


class FreezeTagException(Exception):
    pass


def hash_bytes(b):
    return hashlib.sha1(b).digest()


def hash_file(path):
    with open(path, 'rb') as f:
        return hash_bytes(f.read())


def get_id(freezetag, freezetag_bytes):
    checksum = hash_bytes(freezetag_bytes)[0:4]
    return 'F' + '-'.join([freezetag['frozen']['music_checksum'].hex(),
                           freezetag['frozen']['metadata_checksum'].hex(),
                           checksum.hex()])


def find_ftag():
    freezetag_paths = [p for p in root.iterdir() if p.suffix.lower() == '.ftag']

    if not len(freezetag_paths):
        raise FreezeTagException('No freezetag file found in {0}'.format(root))

    index = 0

    if len(freezetag_paths) > 1:
        print('Multiple freezetags found.')
        for i, path in enumerate(freezetag_paths):
            print('{0}: {1}'.format(i, path))
        choice = ''
        while not choice.isdecimal() or int(choice) < 0 or int(choice) >= len(freezetag_paths):
            choice = input('Select freezetag [0-{0}]: '.format(len(freezetag_paths)-1))
        index = int(choice)

    return freezetag_paths[index]


def walk_dir(path):
    for dirpath, dirnames, filenames in os.walk(path):
        if '.git' in dirpath:
            continue

        dirnames.sort()

        for filename in sorted(filenames):
            if filename.lower().endswith('.ftag'):
                continue

            p = Path(dirpath) / filename
            yield p, p.relative_to(path)




def parse_file(filetype, path):
    with open(path, 'rb') as f:
        return filetype(f.read())


def shave():
    for path, rel_path in walk_dir(root):
        filetype = filetype_for_extension.get(path.suffix.lower(), None)
        if not filetype:
            continue

        music = parse_file(filetype, path)
        metadata = music.strip()

        print(path.name)
        metadata_list = list(filetype.iter_metadata(metadata))
        if len(metadata_list):
            print('    shaved {0}'.format(', '.join('{0} ({1})'.format(label, size)
                for label, size in metadata_list)))
        else:
            print('    no metadata found')

        music.format.build_file(music.instance, path)


def thaw():
    if args.ftag:
        ftag = Path(args.ftag)
    else:
        ftag = find_ftag()

    freeeztag = FreezeFormat.parse_file(ftag)
    tmpdir = ftag.with_suffix('.ftag-tmp')

    if freeeztag.version > VERSION:
        raise FreezeTagException('Freezetag file version greater than freezetag version ({0} > {1}).\n'
                                 'Update freezetag and try again.'.format(freeeztag.version, VERSION))

    frozen = freeeztag.frozen
    to_dir = Path(args.to).resolve() / frozen.root if args.to else root
    to_remove = []

    # Map each checksum to an array of files in case we froze multiple files with identical checksums.
    files = {}
    for f in frozen.files:
        if f.checksum not in files:
            files[f.checksum] = [[], False]
        files[f.checksum][0].append(f)

    for path, rel_path in walk_dir(root):
        filetype = filetype_for_extension.get(path.suffix.lower())
        if not filetype:
            checksum = hash_file(path)
        else:
            music = parse_file(filetype, path)
            music.strip()
            checksum = hash_bytes(filetype.format.build(music.instance))

        if checksum not in files:
            continue

        if not rel_path.parts[0].lower().endswith('.ftag-tmp'):
            to_remove.append(path)

        if files[checksum][1]:
            continue

        files[checksum][1] = True

        for file in files[checksum][0]:
            to_path = tmpdir / file.path
            print('{0} {1}'.format(checksum.hex(), file.path))
            print('    thawing {0}'.format(path))
            to_path.parent.mkdir(parents=True, exist_ok=True)

            if not file.format:
                try:
                    shutil.copy2(path, to_path)
                except shutil.SameFileError:
                    pass
                continue

            music.restore_metadata(file.metadata)
            filetype.format.build_file(music.instance, to_path)
            music.strip()

    found_music = False
    for file in frozen.files:
        if files[file.checksum][1]:
            if file.format:
                found_music = True
        else:
            print('missing: {0} {1}'.format(file.checksum.hex(), file.path), file=sys.stderr)

    if not found_music:
        shutil.rmtree(tmpdir, ignore_errors=True)
        raise FreezeTagException('No matching music files found.')

    if root == to_dir:
        for file in to_remove:
            file.unlink()
            parent = file.parent
            while not len(os.listdir(parent)):
                parent.rmdir()
                parent = parent.parent

    for path, rel_path in walk_dir(tmpdir):
        tmp_path = tmpdir / rel_path
        to_path = to_dir / rel_path
        to_path.parent.mkdir(parents=True, exist_ok=True)
        tmp_path.rename(to_path)

    shutil.rmtree(tmpdir)

    if frozen.root and root == to_dir:
        new_root = root.parent / frozen.root
        if root != new_root:
            print('moving {0} to {1}'.format(root, new_root))
            root.rename(new_root)


def make_file_dict(path, rel_path, format, checksum, metadata):
    dict = {
        'path': rel_path.as_posix(),
        'format': format,
        'checksum': checksum,
        'metadata': metadata,
    }

    if args.backup:
        stat = os.stat(path)
        dict['stat'] = {
            'mtime': stat.st_mtime,
            'size': stat.st_size,
        }
    else:
        dict['stat'] = None

    return dict


def freeze():
    tmp_paths = [p for p in root.iterdir() if p.suffix.lower() == '.ftag-tmp']

    if len(tmp_paths):
        raise FreezeTagException(
            'Interrupted freezetag data found at {0}.\n'
            'Run freezetag thaw again, or delete this directory.'.format(tmp_paths[0]))

    existing = {}
    files = []
    music_checksums = []
    metadata_checksums = []
    last_ftag = (None, 0)
    reprinter = Reprinter()

    reprinter.print('Collecting metadata...')

    if args.backup:
        for f in root.iterdir():
            if not re.match('F\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}\.ftag', f.name):
                continue
            mtime = os.stat(f).st_mtime
            if mtime > last_ftag[1]:
                last_ftag = (f, mtime)
        if last_ftag[0]:
            with open(last_ftag[0], 'rb') as last_file:
                last_ftag_bytes = last_file.read()
            last_ftag_parsed = FreezeFormat.parse(last_ftag_bytes)
            for f in last_ftag_parsed.frozen.files:
                existing[f.path] = f

    existing_path_count = 0

    for path, rel_path in walk_dir(root):
        added = False
        if str(rel_path) in existing:
            stat = os.stat(rel_path)
            f = existing[str(rel_path)]
            if stat.st_size == f.stat.size and abs(stat.st_mtime - f.stat.mtime) < 1e-3:
                files.append(f)
                added = True
                existing_path_count += 1

        filetype = filetype_for_extension.get(path.suffix.lower())
        if not filetype:
            if not added:
                files.append(make_file_dict(path, rel_path, 0, hash_file(path), None))
            reprinter.print('Collecting metadata...{0}'.format(rel_path))
            continue

        if added:
            metadata = f.metadata
            music_checksum = f.checksum
        else:
            music = parse_file(filetype, path)
            metadata = music.strip()
            music_checksum = hash_bytes(filetype.format.build(music.instance))

        metadata_checksum = hash_bytes(filetype.metadata_format.build(metadata))
        metadata_checksums.append(metadata_checksum)
        music_checksums.append(music_checksum)

        if not added:
            files.append(make_file_dict(path, rel_path, registered_filetypes.index(filetype) + 1, music_checksum, metadata))

        reprinter.print('Collecting metadata...{0}'.format(rel_path))

    reprinter.print('Collecting metadata...done')
    print()

    if not len(music_checksums):
        raise FreezeTagException('No music files found.')

    if existing_path_count == len(existing) and existing_path_count == len(files)\
            and last_ftag_parsed.frozen.root == root.name:
        print('No changes since last freezetag ({0}).'.format(last_ftag[0].name))
        return

    print('Building freezetag...')

    freezetag = {
        'signature': b'freezetag',
        'version': 2 if args.backup else 1,
        'frozen': {
            'mode': 1 if args.backup else 0,
            'music_checksum': hash_bytes(b''.join(sorted(music_checksums)))[0:8],
            'metadata_checksum': hash_bytes(b''.join(sorted(metadata_checksums)))[0:4],
            'root': root.name,
            'files': files,
        },
    }

    freezetag_bytes = FreezeFormat.build(freezetag)
    freezetag_id = get_id(freezetag, freezetag_bytes)
    filename = 'F' + datetime.now().strftime('%Y-%m-%d_%H-%M-%S') if args.backup else freezetag_id
    freeze_file = root / '{0}.ftag'.format(filename)
    with open(freeze_file, 'wb') as f:
        f.write(freezetag_bytes)

    print('Freezetag created at {0}'.format(freeze_file))


def show():
    if Path(args.directory).suffix == '.ftag':
        ftag = Path(args.directory)
    else:
        ftag = find_ftag()

    with open(ftag, 'rb') as f:
        freezetag_bytes = f.read()
    freezetag = FreezeFormat.parse(freezetag_bytes)

    if freezetag.version > VERSION:
        raise FreezeTagException('Freezetag file version greater than freezetag version ({0} > {1}).\n'
                                 'Update freezetag and try again.'.format(freezetag.version, VERSION))

    frozen = freezetag.frozen

    if args.json:
        print(json.dumps({
            'version': freezetag.version,
            'mode': freeze_modes[frozen.mode],
            'id': get_id(freezetag, freezetag_bytes),
            'root': frozen.root,
            'files': [{
                'path': f.path,
                'checksum': f.checksum.hex(),
            } for f in frozen.files],
        }, indent=2))
    else:
        print('version: {0}'.format(freezetag.version))
        print('mode:    {0}'.format(freeze_modes[frozen.mode]))
        print('id:      {0}'.format(get_id(freezetag, freezetag_bytes)))
        print('root:    {0} '.format(frozen.root))
        for f in frozen.files:
            print('{0} {1}'.format(f.checksum.hex(), f.path))


args = parse_args()
root = Path(args.directory).resolve()

commands = {
    'freeze': freeze,
    'thaw': thaw,
    'shave': shave,
    'show': show,
}

try:
    commands[args.command]()
except FreezeTagException as e:
    print(e, file=sys.stderr)
    sys.exit(1)
