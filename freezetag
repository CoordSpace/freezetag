#!/usr/bin/env python3
import argparse
import construct
import hashlib
import json
import os
import pprint
import re
import tempfile
import shutil
import sys
from datetime import datetime
from formats.flac import FlacFile, FlacMetadataFormat
from formats.mp3 import Mp3File, Mp3MetadataFormat
from construct import *
from pathlib import Path


# Version 2 is used only for "freeze --backup" freezetags.
# All other freezetags are still created using version 1 so the bytes/IDs stay consistent.
# These can be unified in a future version if the schema is updated.
DEFAULT_VERSION = 1
VERSION = 2

freeze_modes = ['default', 'backup']
registered_filetypes = [FlacFile, Mp3File]
filetype_for_extension = {t.extension:t for t in registered_filetypes}


class Reprinter():
    def __init__(self):
        self.last_width = 0

    def print(self, text):
        text = str(text)
        print(text.ljust(self.last_width, ' '), end='\r')
        self.last_width = len(text)


def get_version():
    if args.backup:
        return VERSION
    return DEFAULT_VERSION


def parse_args():
    parent = argparse.ArgumentParser(add_help=False)
    main = argparse.ArgumentParser(parents=[parent],
        epilog='Use "freezetag [command] --help" for more information about a command.',
        description='Saves, strips, and restores file paths and music metadata.',
        formatter_class=argparse.RawTextHelpFormatter)
    sub = main.add_subparsers(metavar='command', dest='command')
    sub.required = True

    def add_subparser(command, help, description=''):
        return sub.add_parser(command, help=help, description=help + description,
                              formatter_class=argparse.RawTextHelpFormatter, parents=[parent])

    freeze = add_subparser('freeze',
            'Saves paths and music metadata to a freezetag file.',
        '\n\nMusic files with supported extensions (.mp3, .flac) will have their metadata'
          '\nsaved in the .ftag file. All files will have their paths saved in the .ftag'
          '\nfile. Metadata and path state can be restored using "freezetag thaw".'
        '\n\nThe freezetag file will be saved in `directory`. Unless --backup is used, the'
          '\nfreezetag file will be named Fa-b-c.ftag, where:'
          '\n  a is a 16-character segment that uniquely identifies the music'
          '\n  b is an 8-character segment that uniquely identifies the metadata'
          '\n  c is an 8-character segment that uniquely identifies the freezetag'
        '\n\nThe "a" and "b" segments do not change between freezes if any paths change or'
          '\nif any non-music files are modified. Additionally, the "a" segment doesn\'t'
          '\nchange if the music files are retagged.'
        '\n\nThis means if two different .ftag files have the same "a" segment, they'
          '\nrepresent the same set of raw music. If they have both the same "a" and "b"'
          '\nsegments, they represent the same set of raw music AND their metadata.'
    )

    thaw = add_subparser('thaw', 'Restores paths and music metadata from a freezetag file.',
        '\n\nBy default, the files will be renamed and restored in-place inside `directory`.'
           '\nNote that `directory` itself will be renamed to the "root" saved in the'
           '\nfreezetag file.'
           '\n\nIf --to is used, files will instead be copied and restored to a subdirectory'
           '\n(named "root" from the freezetag file) under the `to` directory, leaving the'
           '\nfiles in the source `directory` untouched.')

    shave = add_subparser('shave', 'Strips metadata from all music files.',
            '\n\nOnly music files with supported extensions (.mp3, .flac) will be modified,'
              '\nand only supported metadata (Vorbis comments, ID3) will be stripped.')

    show = add_subparser('show', 'Displays the contents of a freezetag file.')

    for parser in [freeze, thaw, shave]:
        parser.add_argument('directory', nargs='?', default=Path.cwd(),
            help='Directory to process (default: current directory).')

    show.add_argument('path', nargs='?', metavar='path', default=Path.cwd(),
        help='Directory containing .ftag file, or the .ftag file itself\n'
             '(default: current directory)')
    show.add_argument('--json', action='store_true', help='Prints JSON output.')

    thaw.add_argument('--ftag', metavar='path',
        help='Path to Freezetag file to use.'
         '\n\nIf path is a directory, the .ftag in this directory will be'
           '\nused. Otherwise, path must be an .ftag file that will be used'
           '\nto thaw.'
         '\n\nIf --ftag is not specified, the .ftag in `directory` will be'
           '\nused.')
    thaw.add_argument('--to', metavar='directory',
        help='Directory to which thawed files will be copied and restored.'
           '\nIf omitted, files will be renamed and restored in-place.')

    freeze.add_argument('--backup', action='store_true',
        help='Freeze in incremental backup mode.'
        '\n\nThis mode is optimized for repeated incremental backups of the'
          '\nsame directory.'
        '\n\nIn backup mode, the freezetag file will be saved as'
          '\nFyyyy-MM-dd_hh-mm-ss.ftag. File sizes and last modified times'
          '\nwill be written to the freezetag file. On subsequent incremental'
          '\nbackups, the last created freezetag in this directory will be'
          '\nread. Any files whose names haven\'t changed will not have their'
          '\nhashes recalculated, making the freeze operation significantly'
          '\nfaster.')
    freeze.add_argument('--ftag', metavar='path',
        help='Path to output freezetag file.'
        '\n\nIf path is a directory, the freezetag file will be written to'
          '\nthis directory, following the naming specifications outlined'
          '\nabove. Otherwise, the freezetag file will be named and saved'
          '\naccording to the given path.'
       '\n\nIf --ftag is not specified, the freezetag file will be written'
         '\nto `directory`.')

    return main.parse_args()


FrozenFormatV1 = Struct(
    'mode' / Computed(0),
    'music_checksum' / Bytes(8),
    'metadata_checksum' / Bytes(4),
    'root' / CString('utf8'),
    'files' / Compressed(PrefixedArray(Int16ub, Struct(
        'path' / CString('utf8'),
        'format' / Int8ub,
        'checksum' / Bytes(20),
        'metadata' / Switch(this.format, {
            1: FlacFile.metadata_format,
            2: Mp3File.metadata_format,
        }),
    )), 'lzma'),
)

FrozenFormatV2 = Struct(
    'mode' / Int8ub,
    'music_checksum' / Bytes(8),
    'metadata_checksum' / Bytes(4),
    'root' / CString('utf8'),
    'files' / Compressed(PrefixedArray(Int16ub, Struct(
        'path' / CString('utf8'),
        'format' / Int8ub,
        'checksum' / Bytes(20),
        'stat' / If(this._._.mode == 1, Struct(
            'mtime' / Double,
            'size' / Long,
        )),
        'metadata' / Switch(this.format, {
            1: FlacFile.metadata_format,
            2: Mp3File.metadata_format,
        }),
    )), 'lzma'),
)

FreezeFormat = Struct(
    'signature' / Const(b'freezetag'),
    'version'/ Int8ub,
    'frozen' / Switch(this.version, {
        1: FrozenFormatV1,
        2: FrozenFormatV2,
    }, GreedyBytes),
    Terminated,
)


class FreezeTagException(Exception):
    pass


def hash_bytes(b):
    return hashlib.sha1(b).digest()


def hash_file(path):
    with open(path, 'rb') as f:
        return hash_bytes(f.read())


def get_id(freezetag, freezetag_bytes):
    checksum = hash_bytes(freezetag_bytes)[0:4]
    return 'F' + '-'.join([freezetag['frozen']['music_checksum'].hex(),
                           freezetag['frozen']['metadata_checksum'].hex(),
                           checksum.hex()])


def find_ftag(path):
    if not path.exists():
        raise FreezeTagException('Given ftag is not a file or directory: {0}'.format(path))

    if path.is_file():
        return path

    freezetag_paths = [p for p in path.iterdir() if p.suffix.lower() == '.ftag']

    if not len(freezetag_paths):
        raise FreezeTagException('No freezetag file found in {0}'.format(path))

    index = 0

    if len(freezetag_paths) > 1:
        print('Multiple freezetags found in directory: {0}'.format(path.resolve()))
        for i, path in enumerate(freezetag_paths):
            print('{0}: {1}'.format(i, path.name))
        choice = ''
        while not choice.isdecimal() or int(choice) < 0 or int(choice) >= len(freezetag_paths):
            choice = input('Select freezetag [0-{0}], or q to quit: '.format(len(freezetag_paths)-1))
            if choice.lower() == 'q':
                sys.exit(0)
        index = int(choice)

    return freezetag_paths[index]


def walk_dir(path):
    for dirpath, dirnames, filenames in os.walk(path):
        if '.git' in dirpath:
            continue

        dirnames.sort()

        for filename in sorted(filenames):
            if filename.lower().endswith('.ftag'):
                continue

            p = Path(dirpath) / filename
            yield p, p.relative_to(path)




def parse_file(filetype, path):
    with open(path, 'rb') as f:
        return filetype(f.read())


def shave():
    root = Path(args.directory).resolve()

    for path, rel_path in walk_dir(root):
        filetype = filetype_for_extension.get(path.suffix.lower(), None)
        if not filetype:
            continue

        music = parse_file(filetype, path)
        metadata = music.strip()

        print(path.name)
        metadata_list = list(filetype.iter_metadata(metadata))
        if len(metadata_list):
            print('    shaved {0}'.format(', '.join('{0} ({1})'.format(label, size)
                for label, size in metadata_list)))
        else:
            print('    no metadata found')

        music.format.build_file(music.instance, path)


def thaw():
    root = Path(args.directory).resolve()
    ftag = find_ftag(Path(args.ftag or root))

    freeeztag = FreezeFormat.parse_file(ftag)

    if freeeztag.version > VERSION:
        raise FreezeTagException('Freezetag file version greater than freezetag version ({0} > {1}).\n'
                                 'Update freezetag and try again.'.format(freeeztag.version, VERSION))

    frozen = freeeztag.frozen
    to_dir = Path(args.to).resolve() / frozen.root if args.to else root
    tmp_dir = root / ftag.with_suffix('.ftag-tmp').name
    thaw_in_place = root == to_dir

    # Map each checksum to an array of files in case multiple files with identical checksums were frozen.
    file_map = {}
    for f in frozen.files:
        if f.checksum not in file_map:
            file_map[f.checksum] = [[], False]
        file_map[f.checksum][0].append(f)

    print('Processing {0}...'.format(root))

    reprinter = Reprinter()

    # First pass: verify directory and calculate checksums.
    paths = []
    commonpath = None
    unrecognized_found = False
    for path, rel_path in walk_dir(root):
        reprinter.print('Checking...{0}'.format(rel_path))

        filetype = filetype_for_extension.get(path.suffix.lower())
        if not filetype:
            checksum = hash_file(path)
        else:
            music = parse_file(filetype, path)
            music.strip()
            checksum = hash_bytes(filetype.format.build(music.instance))

        if checksum not in file_map:
            unrecognized_found = True
            reprinter.print('    Unrecognized file: {0}'.format(path))
            print()
            continue

        file_map[checksum][1] = True
        paths.append((path, rel_path, file_map[checksum], filetype))
        commonpath = os.path.commonpath(list(filter(None, [commonpath, path])))

    reprinter.print('Checking...done.')
    print()

    if thaw_in_place and unrecognized_found and Path(commonpath) != root:
        print('\nCommon path ({0}) does not match thaw directory ({1}).'.format(commonpath, root))
        print("You're thawing in-place, so the structure of {0} will be changed.".format(root))
        print('This directory may be renamed, and unrecognized files will be left in their paths'
              ' relative to this directory.')
        print('Make sure that you didn\'t intend to thaw {0} instead.'.format(commonpath))
        while True:
            choice = input('Continue anyway? (y/n): ').lower()
            if choice == 'y':
                break
            if choice == 'n':
                sys.exit(0)

    missing_music = False
    for file in frozen.files:
        if not file_map[file.checksum][1]:
            print('    Missing: {0} ({1})'.format(file.path, file.checksum.hex()), file=sys.stderr)
            if file.format:
                missing_music = True

    if missing_music:
        print('One or more music files listed in freezetag are missing.')
        while True:
            choice = input('Continue anyway? (y/n): ').lower()
            if choice == 'y':
                break
            if choice == 'n':
                sys.exit(0)

    import_fn = shutil.move if thaw_in_place else shutil.copy2

    # Second pass: move (or copy) files to tmp_dir and update their metadata.
    for path, rel_path, item, filetype in paths:
        reprinter.print('Thawing metadata...{0}'.format(rel_path))

        if not item[1]:
            continue

        item[1] = False

        num_files = len(item[0])
        for file in item[0]:
            to_path = tmp_dir / file.path
            to_path.parent.mkdir(parents=True, exist_ok=True)

            if not filetype:
                try:
                    import_fn(path, to_path)
                except shutil.SameFileError:
                    pass
                continue

            music = parse_file(filetype, path)
            music.restore_metadata(file.metadata)
            filetype.format.build_file(music.instance, to_path)

        if thaw_in_place and rel_path.parts[0] != tmp_dir.name and path.exists():
            path.unlink()
            parent = path.parent
            while not len(os.listdir(parent)):
                parent.rmdir()
                parent = parent.parent

    reprinter.print('Thawing metadata...done.')
    print()

    # Third pass: move files from tmp_dir to their final destinations.
    for path, rel_path in walk_dir(tmp_dir):
        reprinter.print('Restoring files...{0}'.format(rel_path))
        to_path = to_dir / rel_path
        to_path.parent.mkdir(parents=True, exist_ok=True)
        path.rename(to_path)

    reprinter.print('Restoring files...done.'.format(rel_path))
    print()

    shutil.rmtree(tmp_dir)

    if thaw_in_place:
        new_root = root.parent / frozen.root
        if root != new_root:
            print('Renaming {0} to {1}'.format(root, new_root))
            root.rename(new_root)


def make_file_dict(path, rel_path, format, checksum, metadata):
    dict = {
        'path': rel_path.as_posix(),
        'format': format,
        'checksum': checksum,
        'metadata': metadata,
    }

    if args.backup:
        stat = os.stat(path)
        dict['stat'] = {
            'mtime': stat.st_mtime,
            'size': stat.st_size,
        }
    else:
        dict['stat'] = None

    return dict


def freeze():
    root = Path(args.directory).resolve()
    tmp_paths = [p for p in root.iterdir() if p.suffix.lower() == '.ftag-tmp']

    # We're trying to create a new freeze state, but we found existing freezetag tmp
    # directories. We almost certainly don't want tmp directories to be frozen, so
    # abort and have the user fix it first.
    if len(tmp_paths):
        raise FreezeTagException(
            'Unrestored freezetag data found at {0}.\n'
            'Run freezetag thaw again to finish processing.'.format(tmp_paths[0]))

    to_path = Path(args.ftag or root)
    existing = {}
    files = []
    music_checksums = []
    metadata_checksums = []
    last_ftag = (None, 0)
    reprinter = Reprinter()

    reprinter.print('Collecting metadata...')

    if args.backup:
        to_dir = to_path if to_path.is_dir() else to_path.parent
        for f in to_dir.iterdir():
            if not re.match('F\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}\.ftag', f.name):
                continue
            mtime = os.stat(f).st_mtime
            if mtime > last_ftag[1]:
                last_ftag = (f, mtime)
        if last_ftag[0]:
            with open(last_ftag[0], 'rb') as last_file:
                last_ftag_bytes = last_file.read()
            last_ftag_parsed = FreezeFormat.parse(last_ftag_bytes)
            for f in last_ftag_parsed.frozen.files:
                existing[f.path] = f

    existing_path_count = 0

    for path, rel_path in walk_dir(root):
        added = False
        if str(rel_path) in existing:
            stat = os.stat(path)
            f = existing[str(rel_path)]
            if stat.st_size == f.stat.size and abs(stat.st_mtime - f.stat.mtime) < 1e-3:
                files.append(f)
                added = True
                existing_path_count += 1

        filetype = filetype_for_extension.get(path.suffix.lower())
        if not filetype:
            if not added:
                files.append(make_file_dict(path, rel_path, 0, hash_file(path), None))
            reprinter.print('Collecting metadata...{0}'.format(rel_path))
            continue

        if added:
            metadata = f.metadata
            music_checksum = f.checksum
        else:
            music = parse_file(filetype, path)
            metadata = music.strip()
            music_checksum = hash_bytes(filetype.format.build(music.instance))

        metadata_checksum = hash_bytes(filetype.metadata_format.build(metadata))
        metadata_checksums.append(metadata_checksum)
        music_checksums.append(music_checksum)

        if not added:
            files.append(make_file_dict(path, rel_path, registered_filetypes.index(filetype) + 1, music_checksum, metadata))

        reprinter.print('Collecting metadata...{0}'.format(rel_path))

    reprinter.print('Collecting metadata...done.')
    print()

    if not len(music_checksums):
        raise FreezeTagException('No music files found.')

    if existing_path_count == len(existing) and existing_path_count == len(files)\
            and last_ftag_parsed.frozen.root == root.name:
        print('No changes since last freezetag ({0}).'.format(last_ftag[0].name))
        return

    print('Building freezetag...')

    freezetag = {
        'signature': b'freezetag',
        'version': 2 if args.backup else 1,
        'frozen': {
            'mode': 1 if args.backup else 0,
            'music_checksum': hash_bytes(b''.join(sorted(music_checksums)))[0:8],
            'metadata_checksum': hash_bytes(b''.join(sorted(metadata_checksums)))[0:4],
            'root': root.name,
            'files': files,
        },
    }

    freezetag_bytes = FreezeFormat.build(freezetag)

    if to_path.is_dir():
        freezetag_id = get_id(freezetag, freezetag_bytes)
        filename = 'F' + datetime.now().strftime('%Y-%m-%d_%H-%M-%S') if args.backup else freezetag_id
        to_path = to_path / '{0}.ftag'.format(filename)

    with open(to_path, 'wb') as f:
        f.write(freezetag_bytes)

    print('Freezetag created at {0}'.format(to_path))


def show():
    ftag = find_ftag(Path(args.path))

    with open(ftag, 'rb') as f:
        freezetag_bytes = f.read()
    freezetag = FreezeFormat.parse(freezetag_bytes)

    if freezetag.version > VERSION:
        raise FreezeTagException('Freezetag file version greater than freezetag version ({0} > {1}).\n'
                                 'Update freezetag and try again.'.format(freezetag.version, VERSION))

    frozen = freezetag.frozen

    if args.json:
        print(json.dumps({
            'version': freezetag.version,
            'mode': freeze_modes[frozen.mode],
            'id': get_id(freezetag, freezetag_bytes),
            'root': frozen.root,
            'files': [{
                'path': f.path,
                'checksum': f.checksum.hex(),
            } for f in frozen.files],
        }, indent=2))
    else:
        print('version: {0}'.format(freezetag.version))
        print('mode:    {0}'.format(freeze_modes[frozen.mode]))
        print('id:      {0}'.format(get_id(freezetag, freezetag_bytes)))
        print('root:    {0} '.format(frozen.root))
        for f in frozen.files:
            print('{0} {1}'.format(f.checksum.hex(), f.path))


args = parse_args()

commands = {
    'freeze': freeze,
    'thaw': thaw,
    'shave': shave,
    'show': show,
}

try:
    commands[args.command]()
except FreezeTagException as e:
    print(e, file=sys.stderr)
    sys.exit(1)
